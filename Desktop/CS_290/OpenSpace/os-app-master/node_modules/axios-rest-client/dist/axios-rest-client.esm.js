import axios from 'axios';

/**
 * Create api endpoint
 *
 * ```javascript
 * // Create users collections endpoint
 * const users = createCollectionEnpoint(requestor, 'users')
 *
 * // Fetch all users
 * users()
 * users.all()
 * ```
 *
 * @param Requestor requestor
 * @param String endpoint
 * @param Boolean isCollection
 */
function createApiEndpoint(requestor, endpoint) {
  var isCollection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  var _get = function _get() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return requestor.makeRequest('get', '/' + endpoint, params);
  };
  var _post = function _post(data) {
    return requestor.makeRequest('post', '/' + endpoint, data);
  };

  /**
   *
   * @param {*} params
   */
  var apiEndpoint = function apiEndpoint() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    // calling endpoint() is equivalent to endpoint.all()
    return _get(params);
  };

  if (isCollection) {
    apiEndpoint.all = _get;
    apiEndpoint.create = _post;
    apiEndpoint.find = function (id) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return requestor.makeRequest('get', '/' + endpoint + '/' + id, params);
    };
    apiEndpoint.update = function (id, data) {
      return requestor.makeRequest('put', '/' + endpoint + '/' + id, data);
    };
    apiEndpoint.delete = apiEndpoint.remove = function (id) {
      return requestor.makeRequest('delete', '/' + endpoint + '/' + id);
    };
    apiEndpoint.one = function (key) {
      return requestor.endpoint(endpoint + '/' + key, endpoint + '_' + key, false);
    };
  } else {
    apiEndpoint.get = _get;
    apiEndpoint.post = _post;
    apiEndpoint.put = function (data) {
      return requestor.makeRequest('put', '/' + endpoint, data);
    };
    apiEndpoint.delete = function () {
      return requestor.makeRequest('delete', '/' + endpoint);
    };
  }

  // Wrap the endpoint with a proxy to handle undefined property as another api endpoint
  // undefined property on collection endpoint return entity endpoint
  // and collection endpoint on entity endpoint
  var apiEndpointProxy = new Proxy(apiEndpoint, {
    get: function get(apiEndpoint, prop) {
      if (prop in apiEndpoint) {
        return apiEndpoint[prop];
      }

      return requestor.endpoint(endpoint + '/' + prop, endpoint + '_' + prop, !isCollection);
    }
  });

  return apiEndpointProxy;
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var inRange = function inRange(value, min, max) {
  return value >= min && value <= max;
};

var Requestor = function () {
  function Requestor(config) {
    classCallCheck(this, Requestor);

    this.apiCache = {};
    this.baseUrl = config.baseUrl;
    this.options = {};
    this.currentRequestOptions = {};
    this.requestTransformers = [];
    this.responseTransformers = [];

    var axiosConfig = Object.assign({
      baseURL: this.baseUrl,
      headers: {
        'Accept': 'application/json'
      }
    }, config);

    this._axios = axios.create(axiosConfig);
  }

  /**
   * Get internal axios instance
   *
   * @return Axios
   */


  createClass(Requestor, [{
    key: 'axios',
    value: function axios$$1() {
      return this._axios;
    }

    /**
     * Set request header for all requests
     *
     * @param {String} header
     * @param {String} value
     */

  }, {
    key: 'setHeader',
    value: function setHeader(header, value) {
      this._axios.defaults.headers[header] = value;
    }

    /**
     * Set multiple request headers
     *
     * @param {Object} headers
     */

  }, {
    key: 'setHeaders',
    value: function setHeaders(headers) {
      for (var header in headers) {
        this.setHeader(header, headers[header]);
      }
    }

    /**
     * Create collection endpoint
     *
     * @param String endpoint
     * @param String name
     *
     * @return Proxy[RestApi]
     */

  }, {
    key: 'endpoint',
    value: function endpoint(_endpoint, name) {
      var isCollection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var cacheKey = name || _endpoint.replace(/\//g, '_');

      if (this.apiCache[cacheKey]) {
        return this.apiCache[cacheKey];
      }

      var api = createApiEndpoint(this, _endpoint, isCollection);

      this.apiCache[cacheKey] = api;

      return api;
    }

    /**
     * Create some endpoint
     *
     * @param {*} endpoints
     */

  }, {
    key: 'endpoints',
    value: function endpoints(_endpoints) {
      for (var name in _endpoints) {
        this.endpoint(_endpoints[name], name);
      }
    }

    /**
     * Performs http request using axios
     *
     * @param String method
     * @param String url
     * @param Object paramsOrData
     *
     * @return Promise
     */

  }, {
    key: 'makeRequest',
    value: async function makeRequest(method, url, paramsOrData) {
      var requestConfig = {
        url: url,
        method: method
      };

      if (method === 'get') {
        requestConfig['params'] = paramsOrData;
      } else {
        requestConfig['data'] = paramsOrData;
      }

      // Run request transformers
      if (this.requestTransformers.length) {
        this.requestTransformers.forEach(function (transform) {
          transform(requestConfig);
        });
      }

      try {
        var response = await this._axios.request(requestConfig);
        return this.transformResponse(response);
      } catch (error) {
        if (error.response) {
          return this.transformResponse(error.response);
        }

        throw error;
      }
    }
  }, {
    key: 'transformResponse',
    value: function transformResponse(response) {
      var wrappedResponse = this._wrapAxiosResponse(response);

      // Run request tranformers
      if (this.responseTransformers.length) {
        this.responseTransformers.forEach(function (transformer) {
          return transformer(wrappedResponse);
        });
      }

      return wrappedResponse;
    }
  }, {
    key: 'addRequestTransformer',
    value: function addRequestTransformer(transformer) {
      this.requestTransformers.push(transformer);

      return this;
    }
  }, {
    key: 'addResponseTransformer',
    value: function addResponseTransformer(transformer) {
      this.responseTransformers.push(transformer);

      return this;
    }
  }, {
    key: '_wrapAxiosResponse',
    value: function _wrapAxiosResponse(axiosResponse) {
      var wrappedResponse = {
        status: axiosResponse.status,
        statusText: axiosResponse.statusText,
        config: axiosResponse.config,
        headers: axiosResponse.headers,
        data: axiosResponse.data
      };

      wrappedResponse.isOk = wrappedResponse.status == 200;
      wrappedResponse.isCreated = wrappedResponse.status == 201;
      wrappedResponse.isBadRequest = wrappedResponse.status == 400;
      wrappedResponse.isForbidden = wrappedResponse.status == 403;
      wrappedResponse.isNotFound = wrappedResponse.status == 404;
      wrappedResponse.isServerError = wrappedResponse.status == 500;

      wrappedResponse.isSuccessful = inRange(wrappedResponse.status, 200, 299);
      wrappedResponse.isClientError = inRange(wrappedResponse.status, 400, 499);
      wrappedResponse.isServerError = inRange(wrappedResponse.status, 500, 599);

      return wrappedResponse;
    }
  }]);
  return Requestor;
}();

function axiosRestClient(config) {
  if (!config.baseUrl) {
    throw new Error('config.baseUrl is required');
  }

  var requestor = new Requestor(config);
  var apiProxy = new Proxy(requestor, {
    get: function get(requestor, prop) {
      return prop in requestor ? requestor[prop] : requestor.endpoint(prop);
    }
  });

  return apiProxy;
}

export default axiosRestClient;
